{"tiddlers":{"$:/ahanniga/call/FindNextInPage":{"title":"$:/ahanniga/call/FindNextInPage","created":"20220702120233072","key":"((find-in-page-next))","modified":"20220702222537158","tags":"$:/tags/KeyboardShortcut","type":"text/vnd.tiddlywiki","text":"<$action-scroll-to-match $direction=\"next\"/>"},"$:/ahanniga/call/FindPrevInPage":{"title":"$:/ahanniga/call/FindPrevInPage","created":"20220702155505236","key":"((find-in-page-prev))","modified":"20220702222503024","tags":"$:/tags/KeyboardShortcut","type":"text/vnd.tiddlywiki","text":"<$action-scroll-to-match $direction=\"previous\"/>"},"$:/config/ShortcutInfo/find-in-page-next":{"title":"$:/config/ShortcutInfo/find-in-page-next","created":"20220702154137964","modified":"20220702154351897","tags":"","type":"text/vnd.tiddlywiki","text":"Find next in page"},"$:/config/ShortcutInfo/find-in-page-prev":{"title":"$:/config/ShortcutInfo/find-in-page-prev","created":"20220702155425292","modified":"20220702155442530","tags":"","type":"text/vnd.tiddlywiki","text":"Find previous in page"},"$:/config/ahanniga/find-in-page/auto-highlight":{"title":"$:/config/ahanniga/find-in-page/auto-highlight","text":"yes","type":"text/x-markdown","created":"20220702225510565","modified":"20220702225520796","tags":""},"$:/config/ahanniga/find-in-page/search-tiddler":{"title":"$:/config/ahanniga/find-in-page/search-tiddler","text":"$:/temp/search","type":"text/x-markdown","created":"20220702224103976","modified":"20220702232026815","tags":""},"$:/config/shortcuts/find-in-page-next":{"title":"$:/config/shortcuts/find-in-page-next","created":"20220702232618842","modified":"20220702232618842","type":"text/vnd.tiddlywiki","text":"ctrl-G"},"$:/config/shortcuts/find-in-page-prev":{"title":"$:/config/shortcuts/find-in-page-prev","created":"20220702232611432","modified":"20220702232611432","type":"text/vnd.tiddlywiki","text":"ctrl-shift-G"},"$:/config/shortcuts/sidebar-search":{"title":"$:/config/shortcuts/sidebar-search","created":"20210729125410133","creator":"","modified":"20220703001622484","modifier":"","type":"text/vnd.tiddlywiki","text":"ctrl-shift-F ctrl-F"},"$:/plugins/ahanniga/find-in-page/action.js":{"title":"$:/plugins/ahanniga/find-in-page/action.js","text":"/*\\\ntitle: $:/plugins/ahanniga/find-in-page/action.js\ntype: application/javascript\nmodule-type: widget\n\nMove between search occurences\n\n\\*/\n(function() {\n\n    /*jslint node: false, browser: true */\n    /*global $tw: true */\n    \"use strict\";\n\n    var Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n    var updateHighlighting = require('$:/plugins/ahanniga/find-in-page/update.js');\n\n    var ScrollToMatch = function(parseTreeNode,options) {\n        this.initialise(parseTreeNode,options);\n    };\n\n    let previousIndex = 0;\n    let previousSearchText = \"\";\n\n    /*\n    Inherit from the base widget class\n    */\n    ScrollToMatch.prototype = new Widget();\n\n    /*\n    Render this widget into the DOM\n    */\n    ScrollToMatch.prototype.render = function(parent,nextSibling) {\n        this.computeAttributes();\n        this.execute();\n    };\n\n    /*\n    Compute the internal state of the widget\n    */\n    ScrollToMatch.prototype.execute = function() {\n        this.actionDirection = this.getAttribute(\"$direction\");\n    };\n\n    /*\n    Refresh the widget by ensuring our attributes are up to date\n    */\n    ScrollToMatch.prototype.refresh = function(changedTiddlers) {\n        var changedAttributes = this.computeAttributes();\n        if(changedAttributes[\"$direction\"]) {\n            this.refreshSelf();\n            return true;\n        }\n        return this.refreshChildren(changedTiddlers);\n    };\n\n    /*\n    Invoke the action associated with this widget\n    */\n    ScrollToMatch.prototype.invokeAction = function(triggeringWidget,event) {\n        var self = this;\n        var isHighlightingUpdated = updateHighlighting(true, null, true);\n        var allMatches = $tw.pageContainer.querySelectorAll('mark');\n        if (allMatches.length === 0 || !isHighlightingUpdated) {\n            return true;\n        }\n\n        var searchText = getSearchText();\n        var index = 0;\n        if(searchText === previousSearchText) {\n            index = this.actionDirection === \"previous\"\n                ? getPrevIndex(allMatches.length)\n                : getNextIndex(allMatches.length);\n        }\n\n        console.log(index);\n        allMatches[index].scrollIntoView({\n            behavior: 'auto',\n            block: 'center',\n            inline: 'center'\n        });\n\n        allMatches[index].classList.add(\"selected\")\n        previousIndex = index;\n        previousSearchText = searchText;\n\n        updateCounterTiddler([\"(\", index + 1, \"/\", allMatches.length, \")\"].join(\"\"));\n        return true;\n    }\n\n    function getPrevIndex(len) {\n        return previousIndex - 1 < 0 ? len - 1 : previousIndex - 1;\n    }\n\n    function getNextIndex(len) {\n        return previousIndex + 1 > len - 1 ? 0 : previousIndex + 1;\n    }\n\n    function getSearchText() {\n        return $tw.wiki.getTiddlerText($tw.wiki.getTiddlerText(\"$:/config/ahanniga/find-in-page/search-tiddler\"))\n    }\n\n    function updateCounterTiddler(txt) {\n        var defaultFields = $tw.wiki.getCreationFields();\n        var tiddlerFields = {\n            title: \"$:/temp/ahanniga/find-in-page/counter\",\n            text: txt\n        };\n        $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerFields, defaultFields));\n    }\n\n    exports[\"action-scroll-to-match\"] = ScrollToMatch;\n\n})();\n","type":"application/javascript","module-type":"widget","created":"20220702222710842","modified":"20220702223220629","tags":""},"$:/plugins/ahanniga/find-in-page/buttons/next-match":{"title":"$:/plugins/ahanniga/find-in-page/buttons/next-match","created":"20220702231522203","modified":"20220702231618628","tags":"","type":"text/vnd.tiddlywiki","text":"<$button class=\"tc-btn-invisible find-in-page-next-match\" tooltip=\"Scroll to next matches\">\n    <$action-scroll-to-match $direction=\"next\"/>\n    {{$:/core/images/down-arrow}}\n</$button>"},"$:/plugins/ahanniga/find-in-page/buttons/previous-match":{"title":"$:/plugins/ahanniga/find-in-page/buttons/previous-match","created":"20220702231349306","modified":"20220702231451855","tags":"","type":"text/vnd.tiddlywiki","text":"<$button class=\"tc-btn-invisible find-in-page-previous-match\" tooltip=\"Scroll to previous matches\">\n    <$action-scroll-to-match $direction=\"previous\"/>\n    {{$:/core/images/up-arrow}}\n</$button>\n"},"$:/plugins/ahanniga/find-in-page/css":{"title":"$:/plugins/ahanniga/find-in-page/css","text":".find-in-page-searched-text.find-in-page-counter {\n    white-space: nowrap;\n}\n\n.find-in-page-sidebar {\n    padding: 4px 0px;\n}\n\nbutton.tc-btn-invisible.find-in-page-next-match {\n    margin-left: 8px;\n}\nbutton.tc-btn-invisible.find-in-page-previous-match {\n    margin-right: 8px;\n    margin-left: 4px;\n}\n.find-in-page-searched-text .counter {\n    white-space: nowrap;\n}\nmark.selected {\n    background-color: #3ce03c;\n    border-radius: 2px\n}\n\n@media print {\n    .find-in-page-searched-text {\n        display: none !important;\n    }\n}\n","created":"20220702225746833","modified":"20220703001418707","tags":"$:/tags/Stylesheet","type":"text/css"},"$:/plugins/ahanniga/find-in-page/mark.js":{"title":"$:/plugins/ahanniga/find-in-page/mark.js","text":"/*!***************************************************\n* mark.js v9.0.0\n* https://markjs.io/\n* Copyright (c) 2014–2018, Julian Kühnel\n* Released under the MIT license https://git.io/vwTVl\n*****************************************************/\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Mark = factory());\n}(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  var DOMIterator =\n  /*#__PURE__*/\n  function () {\n    function DOMIterator(ctx) {\n      var iframes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var iframesTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;\n\n      _classCallCheck(this, DOMIterator);\n\n      this.ctx = ctx;\n      this.iframes = iframes;\n      this.exclude = exclude;\n      this.iframesTimeout = iframesTimeout;\n    }\n\n    _createClass(DOMIterator, [{\n      key: \"getContexts\",\n      value: function getContexts() {\n        var ctx,\n            filteredCtx = [];\n\n        if (typeof this.ctx === 'undefined' || !this.ctx) {\n          ctx = [];\n        } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n          ctx = Array.prototype.slice.call(this.ctx);\n        } else if (Array.isArray(this.ctx)) {\n          ctx = this.ctx;\n        } else if (typeof this.ctx === 'string') {\n          ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));\n        } else {\n          ctx = [this.ctx];\n        }\n\n        ctx.forEach(function (ctx) {\n          var isDescendant = filteredCtx.filter(function (contexts) {\n            return contexts.contains(ctx);\n          }).length > 0;\n\n          if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n            filteredCtx.push(ctx);\n          }\n        });\n        return filteredCtx;\n      }\n    }, {\n      key: \"getIframeContents\",\n      value: function getIframeContents(ifr, successFn) {\n        var errorFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n        var doc;\n\n        try {\n          var ifrWin = ifr.contentWindow;\n          doc = ifrWin.document;\n\n          if (!ifrWin || !doc) {\n            throw new Error('iframe inaccessible');\n          }\n        } catch (e) {\n          errorFn();\n        }\n\n        if (doc) {\n          successFn(doc);\n        }\n      }\n    }, {\n      key: \"isIframeBlank\",\n      value: function isIframeBlank(ifr) {\n        var bl = 'about:blank',\n            src = ifr.getAttribute('src').trim(),\n            href = ifr.contentWindow.location.href;\n        return href === bl && src !== bl && src;\n      }\n    }, {\n      key: \"observeIframeLoad\",\n      value: function observeIframeLoad(ifr, successFn, errorFn) {\n        var _this = this;\n\n        var called = false,\n            tout = null;\n\n        var listener = function listener() {\n          if (called) {\n            return;\n          }\n\n          called = true;\n          clearTimeout(tout);\n\n          try {\n            if (!_this.isIframeBlank(ifr)) {\n              ifr.removeEventListener('load', listener);\n\n              _this.getIframeContents(ifr, successFn, errorFn);\n            }\n          } catch (e) {\n            errorFn();\n          }\n        };\n\n        ifr.addEventListener('load', listener);\n        tout = setTimeout(listener, this.iframesTimeout);\n      }\n    }, {\n      key: \"onIframeReady\",\n      value: function onIframeReady(ifr, successFn, errorFn) {\n        try {\n          if (ifr.contentWindow.document.readyState === 'complete') {\n            if (this.isIframeBlank(ifr)) {\n              this.observeIframeLoad(ifr, successFn, errorFn);\n            } else {\n              this.getIframeContents(ifr, successFn, errorFn);\n            }\n          } else {\n            this.observeIframeLoad(ifr, successFn, errorFn);\n          }\n        } catch (e) {\n          errorFn();\n        }\n      }\n    }, {\n      key: \"waitForIframes\",\n      value: function waitForIframes(ctx, done) {\n        var _this2 = this;\n\n        var eachCalled = 0;\n        this.forEachIframe(ctx, function () {\n          return true;\n        }, function (ifr) {\n          eachCalled++;\n\n          _this2.waitForIframes(ifr.querySelector('html'), function () {\n            if (! --eachCalled) {\n              done();\n            }\n          });\n        }, function (handled) {\n          if (!handled) {\n            done();\n          }\n        });\n      }\n    }, {\n      key: \"forEachIframe\",\n      value: function forEachIframe(ctx, filter, each) {\n        var _this3 = this;\n\n        var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n        var ifr = ctx.querySelectorAll('iframe'),\n            open = ifr.length,\n            handled = 0;\n        ifr = Array.prototype.slice.call(ifr);\n\n        var checkEnd = function checkEnd() {\n          if (--open <= 0) {\n            end(handled);\n          }\n        };\n\n        if (!open) {\n          checkEnd();\n        }\n\n        ifr.forEach(function (ifr) {\n          if (DOMIterator.matches(ifr, _this3.exclude)) {\n            checkEnd();\n          } else {\n            _this3.onIframeReady(ifr, function (con) {\n              if (filter(ifr)) {\n                handled++;\n                each(con);\n              }\n\n              checkEnd();\n            }, checkEnd);\n          }\n        });\n      }\n    }, {\n      key: \"createIterator\",\n      value: function createIterator(ctx, whatToShow, filter) {\n        return document.createNodeIterator(ctx, whatToShow, filter, false);\n      }\n    }, {\n      key: \"createInstanceOnIframe\",\n      value: function createInstanceOnIframe(contents) {\n        return new DOMIterator(contents.querySelector('html'), this.iframes);\n      }\n    }, {\n      key: \"compareNodeIframe\",\n      value: function compareNodeIframe(node, prevNode, ifr) {\n        var compCurr = node.compareDocumentPosition(ifr),\n            prev = Node.DOCUMENT_POSITION_PRECEDING;\n\n        if (compCurr & prev) {\n          if (prevNode !== null) {\n            var compPrev = prevNode.compareDocumentPosition(ifr),\n                after = Node.DOCUMENT_POSITION_FOLLOWING;\n\n            if (compPrev & after) {\n              return true;\n            }\n          } else {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }, {\n      key: \"getIteratorNode\",\n      value: function getIteratorNode(itr) {\n        var prevNode = itr.previousNode();\n        var node;\n\n        if (prevNode === null) {\n          node = itr.nextNode();\n        } else {\n          node = itr.nextNode() && itr.nextNode();\n        }\n\n        return {\n          prevNode: prevNode,\n          node: node\n        };\n      }\n    }, {\n      key: \"checkIframeFilter\",\n      value: function checkIframeFilter(node, prevNode, currIfr, ifr) {\n        var key = false,\n            handled = false;\n        ifr.forEach(function (ifrDict, i) {\n          if (ifrDict.val === currIfr) {\n            key = i;\n            handled = ifrDict.handled;\n          }\n        });\n\n        if (this.compareNodeIframe(node, prevNode, currIfr)) {\n          if (key === false && !handled) {\n            ifr.push({\n              val: currIfr,\n              handled: true\n            });\n          } else if (key !== false && !handled) {\n            ifr[key].handled = true;\n          }\n\n          return true;\n        }\n\n        if (key === false) {\n          ifr.push({\n            val: currIfr,\n            handled: false\n          });\n        }\n\n        return false;\n      }\n    }, {\n      key: \"handleOpenIframes\",\n      value: function handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n        var _this4 = this;\n\n        ifr.forEach(function (ifrDict) {\n          if (!ifrDict.handled) {\n            _this4.getIframeContents(ifrDict.val, function (con) {\n              _this4.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);\n            });\n          }\n        });\n      }\n    }, {\n      key: \"iterateThroughNodes\",\n      value: function iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n        var _this5 = this;\n\n        var itr = this.createIterator(ctx, whatToShow, filterCb);\n\n        var ifr = [],\n            elements = [],\n            node,\n            prevNode,\n            retrieveNodes = function retrieveNodes() {\n          var _this5$getIteratorNod = _this5.getIteratorNode(itr);\n\n          prevNode = _this5$getIteratorNod.prevNode;\n          node = _this5$getIteratorNod.node;\n          return node;\n        };\n\n        while (retrieveNodes()) {\n          if (this.iframes) {\n            this.forEachIframe(ctx, function (currIfr) {\n              return _this5.checkIframeFilter(node, prevNode, currIfr, ifr);\n            }, function (con) {\n              _this5.createInstanceOnIframe(con).forEachNode(whatToShow, function (ifrNode) {\n                return elements.push(ifrNode);\n              }, filterCb);\n            });\n          }\n\n          elements.push(node);\n        }\n\n        elements.forEach(function (node) {\n          eachCb(node);\n        });\n\n        if (this.iframes) {\n          this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n        }\n\n        doneCb();\n      }\n    }, {\n      key: \"forEachNode\",\n      value: function forEachNode(whatToShow, each, filter) {\n        var _this6 = this;\n\n        var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n        var contexts = this.getContexts();\n        var open = contexts.length;\n\n        if (!open) {\n          done();\n        }\n\n        contexts.forEach(function (ctx) {\n          var ready = function ready() {\n            _this6.iterateThroughNodes(whatToShow, ctx, each, filter, function () {\n              if (--open <= 0) {\n                done();\n              }\n            });\n          };\n\n          if (_this6.iframes) {\n            _this6.waitForIframes(ctx, ready);\n          } else {\n            ready();\n          }\n        });\n      }\n    }], [{\n      key: \"matches\",\n      value: function matches(element, selector) {\n        var selectors = typeof selector === 'string' ? [selector] : selector,\n            fn = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;\n\n        if (fn) {\n          var match = false;\n          selectors.every(function (sel) {\n            if (fn.call(element, sel)) {\n              match = true;\n              return false;\n            }\n\n            return true;\n          });\n          return match;\n        } else {\n          return false;\n        }\n      }\n    }]);\n\n    return DOMIterator;\n  }();\n\n  var RegExpCreator =\n  /*#__PURE__*/\n  function () {\n    function RegExpCreator(options) {\n      _classCallCheck(this, RegExpCreator);\n\n      this.opt = _extends({}, {\n        'diacritics': true,\n        'synonyms': {},\n        'accuracy': 'partially',\n        'caseSensitive': false,\n        'ignoreJoiners': false,\n        'ignorePunctuation': [],\n        'wildcards': 'disabled'\n      }, options);\n    }\n\n    _createClass(RegExpCreator, [{\n      key: \"create\",\n      value: function create(str) {\n        if (this.opt.wildcards !== 'disabled') {\n          str = this.setupWildcardsRegExp(str);\n        }\n\n        str = this.escapeStr(str);\n\n        if (Object.keys(this.opt.synonyms).length) {\n          str = this.createSynonymsRegExp(str);\n        }\n\n        if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n          str = this.setupIgnoreJoinersRegExp(str);\n        }\n\n        if (this.opt.diacritics) {\n          str = this.createDiacriticsRegExp(str);\n        }\n\n        str = this.createMergedBlanksRegExp(str);\n\n        if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n          str = this.createJoinersRegExp(str);\n        }\n\n        if (this.opt.wildcards !== 'disabled') {\n          str = this.createWildcardsRegExp(str);\n        }\n\n        str = this.createAccuracyRegExp(str);\n        return new RegExp(str, \"gm\".concat(this.opt.caseSensitive ? '' : 'i'));\n      }\n    }, {\n      key: \"sortByLength\",\n      value: function sortByLength(arry) {\n        return arry.sort(function (a, b) {\n          return a.length === b.length ? a > b ? 1 : -1 : b.length - a.length;\n        });\n      }\n    }, {\n      key: \"escapeStr\",\n      value: function escapeStr(str) {\n        return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n      }\n    }, {\n      key: \"createSynonymsRegExp\",\n      value: function createSynonymsRegExp(str) {\n        var _this = this;\n\n        var syn = this.opt.synonyms,\n            sens = this.opt.caseSensitive ? '' : 'i',\n            joinerPlaceholder = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? \"\\0\" : '';\n\n        for (var index in syn) {\n          if (syn.hasOwnProperty(index)) {\n            var keys = Array.isArray(syn[index]) ? syn[index] : [syn[index]];\n            keys.unshift(index);\n            keys = this.sortByLength(keys).map(function (key) {\n              if (_this.opt.wildcards !== 'disabled') {\n                key = _this.setupWildcardsRegExp(key);\n              }\n\n              key = _this.escapeStr(key);\n              return key;\n            }).filter(function (k) {\n              return k !== '';\n            });\n\n            if (keys.length > 1) {\n              str = str.replace(new RegExp(\"(\".concat(keys.map(function (k) {\n                return _this.escapeStr(k);\n              }).join('|'), \")\"), \"gm\".concat(sens)), joinerPlaceholder + \"(\".concat(keys.map(function (k) {\n                return _this.processSynonyms(k);\n              }).join('|'), \")\") + joinerPlaceholder);\n            }\n          }\n        }\n\n        return str;\n      }\n    }, {\n      key: \"processSynonyms\",\n      value: function processSynonyms(str) {\n        if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n          str = this.setupIgnoreJoinersRegExp(str);\n        }\n\n        return str;\n      }\n    }, {\n      key: \"setupWildcardsRegExp\",\n      value: function setupWildcardsRegExp(str) {\n        str = str.replace(/(?:\\\\)*\\?/g, function (val) {\n          return val.charAt(0) === '\\\\' ? '?' : \"\\x01\";\n        });\n        return str.replace(/(?:\\\\)*\\*/g, function (val) {\n          return val.charAt(0) === '\\\\' ? '*' : \"\\x02\";\n        });\n      }\n    }, {\n      key: \"createWildcardsRegExp\",\n      value: function createWildcardsRegExp(str) {\n        var spaces = this.opt.wildcards === 'withSpaces';\n        return str.replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?').replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n      }\n    }, {\n      key: \"setupIgnoreJoinersRegExp\",\n      value: function setupIgnoreJoinersRegExp(str) {\n        return str.replace(/[^(|)\\\\]/g, function (val, indx, original) {\n          var nextChar = original.charAt(indx + 1);\n\n          if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n            return val;\n          } else {\n            return val + \"\\0\";\n          }\n        });\n      }\n    }, {\n      key: \"createJoinersRegExp\",\n      value: function createJoinersRegExp(str) {\n        var joiner = [];\n        var ignorePunctuation = this.opt.ignorePunctuation;\n\n        if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n          joiner.push(this.escapeStr(ignorePunctuation.join('')));\n        }\n\n        if (this.opt.ignoreJoiners) {\n          joiner.push(\"\\\\u00ad\\\\u200b\\\\u200c\\\\u200d\");\n        }\n\n        return joiner.length ? str.split(/\\u0000+/).join(\"[\".concat(joiner.join(''), \"]*\")) : str;\n      }\n    }, {\n      key: \"createDiacriticsRegExp\",\n      value: function createDiacriticsRegExp(str) {\n        var sens = this.opt.caseSensitive ? '' : 'i',\n            dct = this.opt.caseSensitive ? ['aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ', 'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ', 'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń', 'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ', 'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'] : ['aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ', 'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ', 'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ', 'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ', 'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'];\n        var handled = [];\n        str.split('').forEach(function (ch) {\n          dct.every(function (dct) {\n            if (dct.indexOf(ch) !== -1) {\n              if (handled.indexOf(dct) > -1) {\n                return false;\n              }\n\n              str = str.replace(new RegExp(\"[\".concat(dct, \"]\"), \"gm\".concat(sens)), \"[\".concat(dct, \"]\"));\n              handled.push(dct);\n            }\n\n            return true;\n          });\n        });\n        return str;\n      }\n    }, {\n      key: \"createMergedBlanksRegExp\",\n      value: function createMergedBlanksRegExp(str) {\n        return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n      }\n    }, {\n      key: \"createAccuracyRegExp\",\n      value: function createAccuracyRegExp(str) {\n        var _this2 = this;\n\n        var chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\n        var acc = this.opt.accuracy,\n            val = typeof acc === 'string' ? acc : acc.value,\n            ls = typeof acc === 'string' ? [] : acc.limiters,\n            lsJoin = '';\n        ls.forEach(function (limiter) {\n          lsJoin += \"|\".concat(_this2.escapeStr(limiter));\n        });\n\n        switch (val) {\n          case 'partially':\n          default:\n            return \"()(\".concat(str, \")\");\n\n          case 'complementary':\n            lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n            return \"()([^\".concat(lsJoin, \"]*\").concat(str, \"[^\").concat(lsJoin, \"]*)\");\n\n          case 'exactly':\n            return \"(^|\\\\s\".concat(lsJoin, \")(\").concat(str, \")(?=$|\\\\s\").concat(lsJoin, \")\");\n        }\n      }\n    }]);\n\n    return RegExpCreator;\n  }();\n\n  var Mark =\n  /*#__PURE__*/\n  function () {\n    function Mark(ctx) {\n      _classCallCheck(this, Mark);\n\n      this.ctx = ctx;\n      this.ie = false;\n      var ua = window.navigator.userAgent;\n\n      if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n        this.ie = true;\n      }\n    }\n\n    _createClass(Mark, [{\n      key: \"log\",\n      value: function log(msg) {\n        var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'debug';\n        var log = this.opt.log;\n\n        if (!this.opt.debug) {\n          return;\n        }\n\n        if (_typeof(log) === 'object' && typeof log[level] === 'function') {\n          log[level](\"mark.js: \".concat(msg));\n        }\n      }\n    }, {\n      key: \"getSeparatedKeywords\",\n      value: function getSeparatedKeywords(sv) {\n        var _this = this;\n\n        var stack = [];\n        sv.forEach(function (kw) {\n          if (!_this.opt.separateWordSearch) {\n            if (kw.trim() && stack.indexOf(kw) === -1) {\n              stack.push(kw);\n            }\n          } else {\n            kw.split(' ').forEach(function (kwSplitted) {\n              if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n                stack.push(kwSplitted);\n              }\n            });\n          }\n        });\n        return {\n          'keywords': stack.sort(function (a, b) {\n            return b.length - a.length;\n          }),\n          'length': stack.length\n        };\n      }\n    }, {\n      key: \"isNumeric\",\n      value: function isNumeric(value) {\n        return Number(parseFloat(value)) == value;\n      }\n    }, {\n      key: \"checkRanges\",\n      value: function checkRanges(array) {\n        var _this2 = this;\n\n        if (!Array.isArray(array) || Object.prototype.toString.call(array[0]) !== '[object Object]') {\n          this.log('markRanges() will only accept an array of objects');\n          this.opt.noMatch(array);\n          return [];\n        }\n\n        var stack = [];\n        var last = 0;\n        array.sort(function (a, b) {\n          return a.start - b.start;\n        }).forEach(function (item) {\n          var _this2$callNoMatchOnI = _this2.callNoMatchOnInvalidRanges(item, last),\n              start = _this2$callNoMatchOnI.start,\n              end = _this2$callNoMatchOnI.end,\n              valid = _this2$callNoMatchOnI.valid;\n\n          if (valid) {\n            item.start = start;\n            item.length = end - start;\n            stack.push(item);\n            last = end;\n          }\n        });\n        return stack;\n      }\n    }, {\n      key: \"callNoMatchOnInvalidRanges\",\n      value: function callNoMatchOnInvalidRanges(range, last) {\n        var start,\n            end,\n            valid = false;\n\n        if (range && typeof range.start !== 'undefined') {\n          start = parseInt(range.start, 10);\n          end = start + parseInt(range.length, 10);\n\n          if (this.isNumeric(range.start) && this.isNumeric(range.length) && end - last > 0 && end - start > 0) {\n            valid = true;\n          } else {\n            this.log('Ignoring invalid or overlapping range: ' + \"\".concat(JSON.stringify(range)));\n            this.opt.noMatch(range);\n          }\n        } else {\n          this.log(\"Ignoring invalid range: \".concat(JSON.stringify(range)));\n          this.opt.noMatch(range);\n        }\n\n        return {\n          start: start,\n          end: end,\n          valid: valid\n        };\n      }\n    }, {\n      key: \"checkWhitespaceRanges\",\n      value: function checkWhitespaceRanges(range, originalLength, string) {\n        var end,\n            valid = true,\n            max = string.length,\n            offset = originalLength - max,\n            start = parseInt(range.start, 10) - offset;\n        start = start > max ? max : start;\n        end = start + parseInt(range.length, 10);\n\n        if (end > max) {\n          end = max;\n          this.log(\"End range automatically set to the max value of \".concat(max));\n        }\n\n        if (start < 0 || end - start < 0 || start > max || end > max) {\n          valid = false;\n          this.log(\"Invalid range: \".concat(JSON.stringify(range)));\n          this.opt.noMatch(range);\n        } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n          valid = false;\n          this.log('Skipping whitespace only range: ' + JSON.stringify(range));\n          this.opt.noMatch(range);\n        }\n\n        return {\n          start: start,\n          end: end,\n          valid: valid\n        };\n      }\n    }, {\n      key: \"getTextNodes\",\n      value: function getTextNodes(cb) {\n        var _this3 = this;\n\n        var val = '',\n            nodes = [];\n        this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function (node) {\n          nodes.push({\n            start: val.length,\n            end: (val += node.textContent).length,\n            node: node\n          });\n        }, function (node) {\n          if (_this3.matchesExclude(node.parentNode)) {\n            return NodeFilter.FILTER_REJECT;\n          } else {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }, function () {\n          cb({\n            value: val,\n            nodes: nodes\n          });\n        });\n      }\n    }, {\n      key: \"matchesExclude\",\n      value: function matchesExclude(el) {\n        return DOMIterator.matches(el, this.opt.exclude.concat(['script', 'style', 'title', 'head', 'html']));\n      }\n    }, {\n      key: \"wrapRangeInTextNode\",\n      value: function wrapRangeInTextNode(node, start, end) {\n        var hEl = !this.opt.element ? 'mark' : this.opt.element,\n            startNode = node.splitText(start),\n            ret = startNode.splitText(end - start);\n        var repl = document.createElement(hEl);\n        repl.setAttribute('data-markjs', 'true');\n\n        if (this.opt.className) {\n          repl.setAttribute('class', this.opt.className);\n        }\n\n        repl.textContent = startNode.textContent;\n        if(this.opt.highlight) {\n            startNode.parentNode.replaceChild(repl, startNode);\n\t\t}\n        return ret;\n      }\n    }, {\n      key: \"wrapRangeInMappedTextNode\",\n      value: function wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n        var _this4 = this;\n\n        dict.nodes.every(function (n, i) {\n          var sibl = dict.nodes[i + 1];\n\n          if (typeof sibl === 'undefined' || sibl.start > start) {\n            if (!filterCb(n.node)) {\n              return false;\n            }\n\n            var s = start - n.start,\n                e = (end > n.end ? n.end : end) - n.start,\n                startStr = dict.value.substr(0, n.start),\n                endStr = dict.value.substr(e + n.start);\n            n.node = _this4.wrapRangeInTextNode(n.node, s, e);\n            dict.value = startStr + endStr;\n            dict.nodes.forEach(function (k, j) {\n              if (j >= i) {\n                if (dict.nodes[j].start > 0 && j !== i) {\n                  dict.nodes[j].start -= e;\n                }\n\n                dict.nodes[j].end -= e;\n              }\n            });\n            end -= e;\n            eachCb(n.node.previousSibling, n.start);\n\n            if (end > n.end) {\n              start = n.end;\n            } else {\n              return false;\n            }\n          }\n\n          return true;\n        });\n      }\n    }, {\n      key: \"wrapGroups\",\n      value: function wrapGroups(node, pos, len, eachCb) {\n        node = this.wrapRangeInTextNode(node, pos, pos + len);\n        eachCb(node.previousSibling);\n        return node;\n      }\n    }, {\n      key: \"separateGroups\",\n      value: function separateGroups(node, match, matchIdx, filterCb, eachCb) {\n        var matchLen = match.length;\n\n        for (var i = 1; i < matchLen; i++) {\n          var pos = node.textContent.indexOf(match[i]);\n\n          if (match[i] && pos > -1 && filterCb(match[i], node)) {\n            node = this.wrapGroups(node, pos, match[i].length, eachCb);\n          }\n        }\n\n        return node;\n      }\n    }, {\n      key: \"wrapMatches\",\n      value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n        var _this5 = this;\n\n        var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n        this.getTextNodes(function (dict) {\n          dict.nodes.forEach(function (node) {\n            node = node.node;\n            var match;\n\n            while ((match = regex.exec(node.textContent)) !== null && match[matchIdx] !== '') {\n              if (_this5.opt.separateGroups) {\n                node = _this5.separateGroups(node, match, matchIdx, filterCb, eachCb);\n              } else {\n                if (!filterCb(match[matchIdx], node)) {\n                  continue;\n                }\n\n                var pos = match.index;\n\n                if (matchIdx !== 0) {\n                  for (var i = 1; i < matchIdx; i++) {\n                    pos += match[i].length;\n                  }\n                }\n\n                node = _this5.wrapGroups(node, pos, match[matchIdx].length, eachCb);\n              }\n\n              regex.lastIndex = 0;\n            }\n          });\n          endCb();\n        });\n      }\n    }, {\n      key: \"wrapMatchesAcrossElements\",\n      value: function wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n        var _this6 = this;\n\n        var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n        this.getTextNodes(function (dict) {\n          var match;\n\n          while ((match = regex.exec(dict.value)) !== null && match[matchIdx] !== '') {\n            var start = match.index;\n\n            if (matchIdx !== 0) {\n              for (var i = 1; i < matchIdx; i++) {\n                start += match[i].length;\n              }\n            }\n\n            var end = start + match[matchIdx].length;\n\n            _this6.wrapRangeInMappedTextNode(dict, start, end, function (node) {\n              return filterCb(match[matchIdx], node);\n            }, function (node, lastIndex) {\n              regex.lastIndex = lastIndex;\n              eachCb(node);\n            });\n          }\n\n          endCb();\n        });\n      }\n    }, {\n      key: \"wrapRangeFromIndex\",\n      value: function wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n        var _this7 = this;\n\n        this.getTextNodes(function (dict) {\n          var originalLength = dict.value.length;\n          ranges.forEach(function (range, counter) {\n            var _this7$checkWhitespac = _this7.checkWhitespaceRanges(range, originalLength, dict.value),\n                start = _this7$checkWhitespac.start,\n                end = _this7$checkWhitespac.end,\n                valid = _this7$checkWhitespac.valid;\n\n            if (valid) {\n              _this7.wrapRangeInMappedTextNode(dict, start, end, function (node) {\n                return filterCb(node, range, dict.value.substring(start, end), counter);\n              }, function (node) {\n                eachCb(node, range);\n              });\n            }\n          });\n          endCb();\n        });\n      }\n    }, {\n      key: \"unwrapMatches\",\n      value: function unwrapMatches(node) {\n        var parent = node.parentNode;\n        var docFrag = document.createDocumentFragment();\n\n        while (node.firstChild) {\n          docFrag.appendChild(node.removeChild(node.firstChild));\n        }\n\n        parent.replaceChild(docFrag, node);\n\n        if (!this.ie) {\n          parent.normalize();\n        } else {\n          this.normalizeTextNode(parent);\n        }\n      }\n    }, {\n      key: \"normalizeTextNode\",\n      value: function normalizeTextNode(node) {\n        if (!node) {\n          return;\n        }\n\n        if (node.nodeType === 3) {\n          while (node.nextSibling && node.nextSibling.nodeType === 3) {\n            node.nodeValue += node.nextSibling.nodeValue;\n            node.parentNode.removeChild(node.nextSibling);\n          }\n        } else {\n          this.normalizeTextNode(node.firstChild);\n        }\n\n        this.normalizeTextNode(node.nextSibling);\n      }\n    }, {\n      key: \"markRegExp\",\n      value: function markRegExp(regexp, opt) {\n        var _this8 = this;\n\n        this.opt = opt;\n        this.log(\"Searching with expression \\\"\".concat(regexp, \"\\\"\"));\n        var totalMatches = 0,\n            fn = 'wrapMatches';\n\n        var eachCb = function eachCb(element) {\n          totalMatches++;\n\n          _this8.opt.each(element);\n        };\n\n        if (this.opt.acrossElements) {\n          fn = 'wrapMatchesAcrossElements';\n        }\n\n        this[fn](regexp, this.opt.ignoreGroups, function (match, node) {\n          return _this8.opt.filter(node, match, totalMatches);\n        }, eachCb, function () {\n          if (totalMatches === 0) {\n            _this8.opt.noMatch(regexp);\n          }\n\n          _this8.opt.done(totalMatches);\n        });\n      }\n    }, {\n      key: \"mark\",\n      value: function mark(sv, opt) {\n        var _this9 = this;\n\n        this.opt = opt;\n        var totalMatches = 0,\n            fn = 'wrapMatches';\n\n        var _this$getSeparatedKey = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n            kwArr = _this$getSeparatedKey.keywords,\n            kwArrLen = _this$getSeparatedKey.length,\n            handler = function handler(kw) {\n          var regex = new RegExpCreator(_this9.opt).create(kw);\n          var matches = 0;\n\n          _this9.log(\"Searching with expression \\\"\".concat(regex, \"\\\"\"));\n\n          _this9[fn](regex, 1, function (term, node) {\n            return _this9.opt.filter(node, kw, totalMatches, matches);\n          }, function (element) {\n            matches++;\n            totalMatches++;\n\n            _this9.opt.each(element);\n          }, function () {\n            if (matches === 0) {\n              _this9.opt.noMatch(kw);\n            }\n\n            if (kwArr[kwArrLen - 1] === kw) {\n              _this9.opt.done(totalMatches);\n            } else {\n              handler(kwArr[kwArr.indexOf(kw) + 1]);\n            }\n          });\n        };\n\n        if (this.opt.acrossElements) {\n          fn = 'wrapMatchesAcrossElements';\n        }\n\n        if (kwArrLen === 0) {\n          this.opt.done(totalMatches);\n        } else {\n          handler(kwArr[0]);\n        }\n      }\n    }, {\n      key: \"markRanges\",\n      value: function markRanges(rawRanges, opt) {\n        var _this10 = this;\n\n        this.opt = opt;\n        var totalMatches = 0,\n            ranges = this.checkRanges(rawRanges);\n\n        if (ranges && ranges.length) {\n          this.log('Starting to mark with the following ranges: ' + JSON.stringify(ranges));\n          this.wrapRangeFromIndex(ranges, function (node, range, match, counter) {\n            return _this10.opt.filter(node, range, match, counter);\n          }, function (element, range) {\n            totalMatches++;\n\n            _this10.opt.each(element, range);\n          }, function () {\n            _this10.opt.done(totalMatches);\n          });\n        } else {\n          this.opt.done(totalMatches);\n        }\n      }\n    }, {\n      key: \"unmark\",\n      value: function unmark(opt) {\n        var _this11 = this;\n\n        this.opt = opt;\n        var sel = this.opt.element ? this.opt.element : '*';\n        sel += '[data-markjs]';\n\n        if (this.opt.className) {\n          sel += \".\".concat(this.opt.className);\n        }\n\n        this.log(\"Removal selector \\\"\".concat(sel, \"\\\"\"));\n        this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function (node) {\n          _this11.unwrapMatches(node);\n        }, function (node) {\n          var matchesSel = DOMIterator.matches(node, sel),\n              matchesExclude = _this11.matchesExclude(node);\n\n          if (!matchesSel || matchesExclude) {\n            return NodeFilter.FILTER_REJECT;\n          } else {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }, this.opt.done);\n      }\n    }, {\n      key: \"opt\",\n      set: function set(val) {\n        this._opt = _extends({}, {\n          'element': '',\n          'className': '',\n          'exclude': [],\n          'iframes': false,\n          'iframesTimeout': 5000,\n          'separateWordSearch': true,\n          'acrossElements': false,\n          'ignoreGroups': 0,\n          'each': function each() {},\n          'noMatch': function noMatch() {},\n          'filter': function filter() {\n            return true;\n          },\n          'done': function done() {},\n          'debug': false,\n          'log': window.console\n        }, val);\n      },\n      get: function get() {\n        return this._opt;\n      }\n    }, {\n      key: \"iterator\",\n      get: function get() {\n        return new DOMIterator(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);\n      }\n    }]);\n\n    return Mark;\n  }();\n\n  function Mark$1(ctx) {\n    var _this = this;\n\n    var instance = new Mark(ctx);\n\n    this.mark = function (sv, opt) {\n      instance.mark(sv, opt);\n      return _this;\n    };\n\n    this.markRegExp = function (sv, opt) {\n      instance.markRegExp(sv, opt);\n      return _this;\n    };\n\n    this.markRanges = function (sv, opt) {\n      instance.markRanges(sv, opt);\n      return _this;\n    };\n\n    this.unmark = function (opt) {\n      instance.unmark(opt);\n      return _this;\n    };\n\n    return this;\n  }\n\n  return Mark$1;\n\n})));","created":"20220702223702748","modified":"20220702223901132","module-type":"library","tags":"","type":"application/javascript"},"$:/plugins/ahanniga/find-in-page/startup-action.js":{"title":"$:/plugins/ahanniga/find-in-page/startup-action.js","text":"/*\\\ntitle: $:/plugins/ahanniga/find-in-page/startup-action.js\ntype: application/javascript\nmodule-type: startup\n\nAdd event listeners to highlight searched text\n\n\\*/\n\n(function() {\n\n\t/*jslint node: false, browser: true */\n\t/*global $tw: true */\n\t\"use strict\";\n\n\tvar updateHighlighting = require('$:/plugins/ahanniga/find-in-page/update.js');\n\n\t// Export name and synchronous status\n\texports.name = \"highlightsearch\";\n\texports.platforms = [\"browser\"];\n\texports.after = [\"story\"];\n\texports.synchronous = true;\n\n\texports.startup = function() {\n\t\t$tw.wiki.addEventListener(\"change\",function(changedTiddlers) {\n\t\t\tif(Object.keys(changedTiddlers).reduce(function(accumulator,current) {\n\t\t\t\treturn accumulator || searchTextBecameEmpty(current) || (autoHighlightEnabled() && searchPopupBecameHidden(current,changedTiddlers[current]))\n\t\t\t},false)) {\n\t\t\t\tupdateHighlighting();\n\t\t\t}\n\t\t});\n\t\t$tw.hooks.addHook(\"th-navigating\",function(event) {\n\t\t\tif(autoHighlightEnabled()) {\n\t\t\t  // TODO: It should update highlight only if navigated from search results - how to check this?\n\t\t\t  setTimeout(function() {\n\t\t\t    updateHighlighting(true);\n\t\t\t  }, $tw.wiki.getTiddlerText(\"$:/config/AnimationDuration\"));\n\t\t    }\n\t\t\treturn (event);\n\t\t});\n\t\t$tw.hooks.addHook(\"th-editing-tiddler\",function(event) {\n\t\t\tclearHighlighting();\n\t\t\treturn (event);\n\t\t});\n\t\t$tw.hooks.addHook(\"th-new-tiddler\",function(event) {\n\t\t\tclearHighlighting();\n\t\t\treturn (event);\n\t\t});\n\t};\n\n\tfunction autoHighlightEnabled() {\n\t\treturn $tw.wiki.getTiddlerText(\"$:/config/ahanniga/find-in-page/auto-highlight\") === \"yes\";\n\t}\n\n\tfunction searchPopupBecameHidden(title,value) {\n\t\treturn (title.indexOf(\"$:/state/popup/search-dropdown\") === 0) && value.deleted\n\t}\n\n\tfunction searchTextBecameEmpty(title) {\n\t\tvar searchTiddler = $tw.wiki.getTiddlerText(\"$:/config/ahanniga/find-in-page/search-tiddler\");\n\t\treturn title === searchTiddler && $tw.wiki.getTiddlerText(searchTiddler) === \"\"\n\t}\n\n\tfunction clearHighlighting() {\n\t\tsetTimeout(function() {\n\t\t\tupdateHighlighting(true, \"\");\n\t\t}, $tw.wiki.getTiddlerText(\"$:/config/AnimationDuration\"));\n\t}\n})();\n","type":"application/javascript","module-type":"startup","created":"20220702225205447","modified":"20220702231026351","tags":""},"$:/plugins/ahanniga/find-in-page/templates/counter":{"title":"$:/plugins/ahanniga/find-in-page/templates/counter","created":"20220703000258630","modified":"20220703001339054","tags":"","type":"text/vnd.tiddlywiki","text":"<span class=\"counter\"> {{$:/temp/ahanniga/find-in-page/counter}} </span>"},"$:/plugins/ahanniga/find-in-page/templates/sidebar":{"title":"$:/plugins/ahanniga/find-in-page/templates/sidebar","created":"20220702224747531","modified":"20220703001356020","tags":"$:/tags/SideBarSegment","type":"text/vnd.tiddlywiki","text":"<div class=\"find-in-page-searched-text find-in-page-sidebar\">\n\t<$list filter=\"[{$:/config/ahanniga/find-in-page/search-tiddler}get[text]]\" emptyMessage=\"&nbsp;\">\n\t\tFind in page: {{$:/plugins/ahanniga/find-in-page/buttons/next-match}} {{$:/plugins/ahanniga/find-in-page/buttons/previous-match}} {{$:/plugins/ahanniga/find-in-page/templates/counter}}\n\t</$list>\n</div>\n"},"$:/plugins/ahanniga/find-in-page/update.js":{"title":"$:/plugins/ahanniga/find-in-page/update.js","text":"/*\\\ntitle: $:/plugins/ahanniga/find-in-page/update.js\ntype: application/javascript\nmodule-type: library\n\nUpdate highlight of searched text (find in page)\n\n\\*/\n\nvar\n\tMark = require(\"$:/plugins/ahanniga/find-in-page/mark.js\"),\n\tmarkInstance;\n\tpreviousSearchedText = '';\n\nmodule.exports = function(force = false, customSearchedText = null, highlight = false) {\n\tvar searchTiddler = $tw.wiki.getTiddlerText(\"$:/config/ahanniga/find-in-page/search-tiddler\");\n\tvar searchedText = customSearchedText !== null ? customSearchedText : $tw.wiki.getTiddlerText(searchTiddler) || \"\";\n\tvar totalCounter = 0;\n\n\tif((searchedText === previousSearchedText) && !force) return false;\n\n\tif(!markInstance) markInstance = new Mark(document.getElementsByClassName(\"tc-story-river\")[0]);\n\tmarkInstance.unmark();\n\tif(searchedText !== \"\") markInstance.mark(searchedText, {\n\t\texclude: [\n\t\t\t\".tc-tiddler-edit-frame *\"\n\t\t],\n\t\tfilter: function(node, term, count) {\n\t\t\ttotalCounter = count + 1;\n\t\t\treturn true;\n\t\t},\n        highlight: highlight\n\t});\n\tsetCounterTiddler(totalCounter);\n\tpreviousSearchedText = searchedText;\n\treturn true;\n};\n\nfunction setCounterTiddler(totalCounter) {\n\tvar defaultFields = $tw.wiki.getCreationFields();\n\tvar tiddlerFields = {\n\t\ttitle: \"$:/temp/ahanniga/find-in-page/counter\",\n\t\ttext: \"(\" + totalCounter + \")\"\n\t};\n\t$tw.wiki.addTiddler(new $tw.Tiddler(tiddlerFields, defaultFields));\n}\n","type":"application/javascript","module-type":"library","created":"20220702223355648","modified":"20220702224419549","tags":""},"$:/tags/SideBarSegment":{"title":"$:/tags/SideBarSegment","created":"20220702233239833","list":"$:/core/ui/SideBarSegments/site-title $:/core/ui/SideBarSegments/site-subtitle $:/core/ui/SideBarSegments/page-controls $:/plugins/ahanniga/find-in-page/templates/sidebar $:/core/ui/SideBarSegments/search $:/core/ui/SideBarSegments/tabs $:/plugins/Gk0Wk/sidebar-resizer/resizer","modified":"20220702233239833","type":"text/vnd.tiddlywiki"},"$:/plugins/ahanniga/find-in-page-plugin/License":{"title":"$:/plugins/ahanniga/find-in-page-plugin/License","type":"text/plain","text":"MIT License\n\nCopyright (c) 2022, A Hannigan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."},"$:/plugins/ahanniga/find-in-page-plugin/README":{"title":"$:/plugins/ahanniga/find-in-page-plugin/README","text":"\\define plugin() $:/plugins/ahanniga/find-in-page-plugin\n\\define install()\n<$list\n  filter=\"[<transclusion>prefix[{$(plugin)$/README|$(plugin)$/README|||}]]\"\n  emptyMessage=\"$(plugin)$\"\n>\n{{ $(plugin)$||$:/core/ui/Components/plugin-info }}\n</$list>\n\\end\n\nThis simulates the \"Find-in-Page\" browser function for [[Electron|https://www.electronjs.org/]] and [[Tiddly Desktop|https://github.com/TiddlyWiki/TiddlyDesktop/]] wikis. It works on single-file wikis too.\n\nThis code is based on the [[Highlight Searched Text plugin|https://github.com/bimlas/tw5-highlight-searched-text]] by [[bimlas|https://github.com/bimlas]], but with incremental searching similar to the way the browser functions.\n\n!! Install\n\n[[Manually install|https://tiddlywiki.com/#Manually%20installing%20a%20plugin]] the plugin by dragging this link to your ~TiddlyWiki:\n\n<<install>>\n\nThen save and refresh your ~TiddlyWiki.\n\n"}}}